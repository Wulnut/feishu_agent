# 脚本硬编码问题分析与改进建议

## 1. 当前现状分析

在开发和调试飞书项目 API 的过程中，为了快速验证功能，现有的 `scripts/` 目录下的脚本大量使用了**硬编码 (Hardcoding)**。虽然这在初期探索阶段是必要的，但在向生产级应用演进时，这种做法存在严重的可维护性和扩展性问题。

### 主要硬编码类型

1. **项目空间标识 (Project Key)**
   - 现状: 脚本中常出现 `project_key = "67dc030b05a5fc19988f791b"` 或 `project_name = "Project Management"`。
   - 问题: 项目 Key 会随环境（开发/测试/生产）变化，或随项目重命名而失效。

2. **工作项类型标识 (Work Item Type Key)**
   - 现状: 大量使用 `ISSUE_TYPE_KEY = "670f3cdaddd89a6fa8f18e65"` (Issue管理)。
   - 问题: 不同空间或不同租户下，即便是同名的 "Issue管理"，其 `type_key` 也可能完全不同。

3. **字段标识 (Field Key)**
   - 现状: 关键字段如 `field_3bf6c0` (关联项目) 直接写死。
   - 问题: 自定义字段的 Key 是随机生成的，在不同项目中完全不可复用。

4. **选项值 (Option Value)**
   - 现状: 优先级映射 `{"P0": "option_1", "P2": "option_3"}`。
   - 问题: 选项的 Key (如 `option_3`) 可能因配置修改而变动，甚至 Label (如 "P0") 也可能被改为 "High"。

## 2. 改进思路：配置与动态发现分离

为了构建健壮的 Agent 生态，我们需要建立清晰的参数来源分层机制：

1. **用户配置层 (Configuration)**: 相对固定的业务上下文，由用户通过环境变量或入参指定。
2. **动态发现层 (Discovery)**: 系统内部标识符，由程序通过 API 自动解析。

### 2.1 用户配置层 (相对固定)

这些参数代表用户的**业务意图**，应支持通过 `.env` 或 MCP Tool 参数传入：

- `TARGET_PROJECT_NAME`: 目标项目名称（如 "Project Management"）
- `DEFAULT_ASSIGNEE`: 默认经办人（邮箱或用户名，如 "zhangsan@example.com"）
- `DEFAULT_REPORTER`: 默认报告人
- `WORK_ITEM_TYPE_NAME`: 目标工作项类型名称（如 "Issue管理"）

### 2.2 动态发现层 (全动态)

在使用任何具体 Key 之前，先进行元数据查询，将用户的**业务意图**转换为系统的**技术标识**：

1. **空间发现**: 根据 `TARGET_PROJECT_NAME` -> 查找 `project_key`。
2. **用户发现**: 根据 `DEFAULT_ASSIGNEE` -> 查找 `user_key`。
3. **类型发现**: 根据 `WORK_ITEM_TYPE_NAME` -> 查找 `type_key`。
4. **字段发现**: 遍历 `/field/all`，将人类可读字段名（"关联项目"）-> 转换为 `field_key`。
5. **选项发现**: 对于 Select 字段，解析元数据中的 `options`，建立 `Label -> Value` 的动态映射。

### 2.3 临时存储与缓存 (Registry)

由于元数据查询耗时较长（通常需要多次 API 调用），必须引入**运行时注册表 (Runtime Registry)** 或**缓存层**。

**建议架构**:

```python
class ProjectMetadataRegistry:
    def __init__(self, client, project_name):
        self.project_key = None
        self.type_map = {}  # "Issue管理" -> "type_key_xxx"
        self.field_map = {} # "Issue管理": {"优先级": "priority", "关联项目": "field_xxx"}
        self.option_map = {} # "Issue管理": {"优先级": {"P0": "option_1"}}
        self.user_map = {}   # "zhangsan" -> "user_key_xxx"

    async def initialize(self):
        # 1. 获取 Project Key
        # 2. 获取所有 Type
        # 3. 懒加载：当请求特定 Type 时，再获取其 Field 和 Option 定义
```

## 3. 具体改进计划 (Action Plan)

### 第一阶段：封装基础元数据服务
- 创建 `src/providers/project/metadata_service.py`。
- 实现 `get_type_key_by_name(type_name)`。
- 实现 `get_field_key_by_name(type_key, field_name)`。
- 实现 `get_option_value_by_label(type_key, field_key, label)`。
- 实现 `get_user_key_by_email_or_name(identifier)`。

### 第二阶段：重构现有脚本
- 废弃 `scripts/work_items/crud/issue_crud.py` 中的 `PRIORITY_MAP` 常量。
- 改为在 `main` 函数启动时，先调用 `metadata_service` 构建当前环境的映射表。
- 引入 `config.py` 或 `argparse` 来接收 `project_name` 等用户配置。

### 第三阶段：MCP Tool 集成
- 在 MCP Tool 的实现中，**严禁使用硬编码 Key**。
- Tool 的输入参数应为人类可读名称（如 `priority="P0"`），内部自动转换为 `option_value`。
- 默认值（如经办人）优先从环境变量读取，如果未配置则留空或报错。

## 4. 示例代码对比

**当前 (Bad):**
```python
field_value_pairs.append({
    "field_key": "field_3bf6c0",  # 硬编码，换个环境必挂
    "field_value": ["12345"]
})
```

**目标 (Good):**
```python
# 1. 从配置获取意图
target_field_name = "关联项目"

# 2. 动态获取字段 Key
related_field_key = await meta.get_field_key("Issue管理", target_field_name)

# 3. 使用动态 Key
field_value_pairs.append({
    "field_key": related_field_key,
    "field_value": ["12345"]
})
```

## 总结

摒弃硬编码是项目从"脚本脚本"走向"工程化产品"的关键一步。通过**配置注入 + 动态元数据解析**，我们可以确保 Agent 能够在任何飞书项目空间中自适应运行，同时给予用户充分的定制灵活性。
